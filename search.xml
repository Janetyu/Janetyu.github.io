<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[哈希表入门]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[哈希表是一种以键值对来组织数据的数据结构，它需要哈希函数，用来支持快速地插入和搜索数据。 哈希表的原理 哈希表的关键是通过哈希函数，将键( key )映射到存储桶(Bucket)： \1. 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中； \2. 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。 设计哈希表的关键 哈希函数哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。 哈希函数（散列函数）取决于键值的范围和桶的数量。 可以看一下哈希函数的示例： 设计哈希函数的思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射，然而很多时候是没办法达到完美的，只能在桶的数量和桶的容量之间做出权衡。 冲突解决在大多数情况下，冲突几乎是不可避免的。 假设我们用 y = x ％ 5 作为哈希函数，1987 和 2 都分配给了桶 2，这是一个冲突。 冲突解决算法应该解决以下几个问题： \1. 如何组织在同一个桶中的值？ \2. 如果为同一个桶分配了太多的值，该怎么办？ \3. 如何在特定的桶中搜索目标值？ 这些问题都跟桶的容量和可能映射到同一个桶的键的数量有关。 一般来说，假设一个桶的最大存储键的数量为 n ，如果这个 n 是常数或者比较小，可以直接用一个数组来代表桶，如果这个 n 是可变或很大，我们就需要用到高度平衡的二叉树来做了。 通过代码理解哈希表no code no talk. 了解了哈希的基本概念后，怎么也得去学一下用代码实现才能真正地理解吧。 下面就用 golang 来实现简单的 哈希集合 hashset 与 哈希映射 hashmap。要知道，哈希表中插入和搜索是最基本的操作了，实现中也是主要包含这些部分。 建议看到要求后，自己想一想该怎么实现比较好，用自己擅长的语言即可。 设计哈希集合要求： 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789101112131415161718&gt; MyHashSet hashSet = new MyHashSet();&gt; &gt; hashSet.add(1); &gt; &gt; hashSet.add(2); &gt; &gt; hashSet.contains(1); // 返回 true&gt; &gt; hashSet.contains(3); // 返回 false (未找到)&gt; &gt; hashSet.add(2); &gt; &gt; hashSet.contains(2); // 返回 true&gt; &gt; hashSet.remove(2); &gt; &gt; hashSet.contains(2); // 返回 false (已经被删除)&gt; 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type MyHashSet struct &#123; table []bool &#125;/** Initialize your data structure here. */func Constructor() MyHashSet &#123; return MyHashSet&#123;table:make([]bool,1000001)&#125; &#125;func (this *MyHashSet) Add(key int) &#123; this.table[key] = true &#125;func (this *MyHashSet) Remove(key int) &#123; this.table[key] = false &#125;/** Returns true if this set contains the specified element */func (this *MyHashSet) Contains(key int) bool &#123; return this.table[key]&#125;/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */ 设计哈希映射要求: 不使用任何内建的哈希表库设计一个哈希映射 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 示例： 123456789101112131415161718&gt; MyHashMap hashMap = new MyHashMap();&gt; &gt; hashMap.put(1, 1); &gt; &gt; hashMap.put(2, 2); &gt; &gt; hashMap.get(1); // 返回 1&gt; &gt; hashMap.get(3); // 返回 -1 (未找到)&gt; &gt; hashMap.put(2, 1); // 更新已有的值&gt; &gt; hashMap.get(2); // 返回 1 &gt; &gt; hashMap.remove(2); // 删除键为2的数据&gt; &gt; hashMap.get(2); // 返回 -1 (未找到) &gt; 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127type KV struct &#123; K int V int&#125;type MyHashMap struct &#123; data [1000][]KV&#125;func hash(key int) int &#123; return key%1000&#125;/** Initialize your data structure here. */func Constructor() MyHashMap &#123; return MyHashMap&#123;[1000][]KV&#123;&#125;&#125;&#125;/** value will always be non-negative. */func (this *MyHashMap) Put(key int, value int) &#123; h := hash(key) bkt := this.data[h] insert := -1 for i := 0; i &lt; len(bkt); i++ &#123; if bkt[i].K == key &#123; bkt[i].V = value return &#125; if bkt[i].K == -1 &#123; insert = i &#125; &#125; if insert != -1 &#123; bkt[insert].K = key bkt[insert].V = value &#125; else &#123; this.data[h] = append(bkt, KV&#123;key, value&#125;) &#125;&#125;/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */func (this *MyHashMap) Get(key int) int &#123; h := hash(key) bkt := this.data[h] for _, k := range bkt &#123; if k.K == key &#123; return k.V &#125; &#125; return -1&#125;/** Removes the mapping of the specified value key if this map contains a mapping for the key */func (this *MyHashMap) Remove(key int) &#123; h := hash(key) bkt := this.data[h] for i := 0; i &lt; len(bkt); i++ &#123; if bkt[i].K == key &#123; bkt[i].K = -1 return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 以上代码借鉴于 leetcode 复杂度分析空间复杂度关于哈希表的空间复杂度，其实也比较明显了，也就是当有 M 个键的时候，那哈希表的空间复杂度也是 O(M) 。 时间复杂度而时间复杂度呢，按照上面的说法，即跟桶的最大存储键值得大小有关，如果存储最大值是个常数，我们可以用数组来当桶，那插入和搜索的时间复杂度都是 O(1)。 如果在最坏的情况下，桶大小的最大值将为 N，也就是可变的，那我们就会用到高度平衡的二叉树作为桶。插入时时间复杂度为 O(1)，搜索时为 O(N)。 内置的哈希表原理 内置哈希表的典型设计是： \1. 键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有hashcode 。此 hashcode 可以通过映射函数来获得存储区索引。 \2. 每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。 \3. 如果在同一个桶中有太多的值（会设置临界值进行判断），这些值将被保留在一个高度平衡的二叉树搜索树中。 这样设计带来的好处便是，插入和搜索的平均时间复杂度仍为 O(1)。 最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。很显然，这需要对这个临界值的设置有巧妙的处理。 今天就讲这么多啦，希望通过本篇的讲解，能让大家对哈希表的结构及原理有更深刻的认识，也十分欢迎大家能在评论区发表自己的看法哦 我是鱼卷少年，我们下次见。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【leetcode】136.只出现一次的数字]]></title>
    <url>%2F2019%2F04%2F22%2Fleetcode136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[leetcode题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 思路 1：我在做这个题的时候，首先是想到了暴力的解法，也就是两层 for 循环，逐一比对，自身与自身不比较，就可以获得答案，我是用 go 写的，代码如下： 12345678910111213141516171819202122232425func singleNumber(nums []int) int &#123; length := len(nums) if length == 1 &#123; return nums[0] &#125; target := nums[0] for i:= 0; i &lt; length; i++ &#123; flag := true for j := 0; j &lt; length; j++ &#123; if i == j &#123; continue &#125; else if nums[i] == nums[j] &#123; flag = false break &#125; &#125; if flag &#123; target = nums[i] return target &#125; &#125; return target&#125; 显然，这并未达到线性时间复杂度，所以肯定有优化的空间，那究竟用什么方法才可以减少时间复杂度呢？ 其实根据这个，言下之意，通过某种方法，可以只用一层循环就可以达到目的。随即想了好久后，我得出： 思路 2：可以通过位运算中的异或运算来做，因为题目说了，只有一个是不同的，其他都是两个相同的数字，用异或，可以让两个相同的数变为 0。 1234567func singleNumber(nums []int) int &#123; result := 0 for _, val := range nums &#123; result ^= val &#125; return result&#125; 好的，提交完成，代码通过。 那么问题来了： 为什么会用到异或呢？异或的本质是什么？ 如果拓展到有三个数相同，而不是两个数相同，又该怎么做呢？ 欢迎在评论区评论，说说你的想法。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
