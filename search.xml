<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【剑指offer】重建二叉树]]></title>
    <url>%2F2019%2F06%2F15%2F%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 输入 前序遍历序列{1,2,4,7,3,5,6,8} 中序遍历序列{4,7,2,1,5,3,8,6} 则重建二叉树并返回。 分析这道题还是比较简单的，我们知道 前序遍历的顺序为：根左右 中序遍历的顺序为：左根右 递归思想: 我们先根据前序遍历序列的第一个确定根，然后在中序遍历的序列中找到根的位置，根左边的就是其左子树，右边就是其右子树 构建根和左右子树 递归的进行1和2 实现思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( "fmt")type TreeNode struct { Val int Left *TreeNode Right *TreeNode}func printPreOrder(root *TreeNode) { if root != nil { fmt.Printf("%d ", root.Val) printInOrder(root.Left) printInOrder(root.Right) }}func printInOrder(root *TreeNode) { if root != nil { printInOrder(root.Left) fmt.Printf("%d ", root.Val) printInOrder(root.Right) }}func reConstructBinaryTree(pre []int,in []int) *TreeNode { if len(pre) != len(in) || len(pre) == 0 { return nil } // find root in preOrder and rootIndex in InOrder rootVal := pre[0] rootIndex := 0 for i := 0; i < len(in) ; i++ { if in[i] == rootVal { rootIndex = i } } inL,inR := in[:rootIndex],in[rootIndex+1:] preL, preR := pre[1:rootIndex+1],pre[rootIndex+1:] Left := reConstructBinaryTree(preL,inL) Right := reConstructBinaryTree(preR,inR) return &TreeNode{Val: rootVal, Left: Left, Right: Right}}func main() { pre := []int{1,2,4,7,3,5,6,8} in := []int{4,7,2,1,5,3,6,8} fmt.Println("preOder: ", pre) fmt.Println("inOrder: ", in) // Reconstruct fmt.Println("\nReconstruct Binary Tree... \n ",) root := reConstructBinaryTree(pre, in) // test fmt.Printf("preOder from Tree reconstructed: ") printPreOrder(root) fmt.Printf("\n") fmt.Printf("inOder from Tree reconstructed: ") printInOrder(root) fmt.Printf("\n")}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】从尾到头打印链表]]></title>
    <url>%2F2019%2F06%2F14%2F%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，从尾到头打印链表每个节点的值。 输入描述: 输入为链表的表头 输出描述: 输出为需要打印的“新链表”的表头 反转链表首先我们想到的就是反转链表了,如果把链表反转了，然后再返回头，这样再次遍历的时候就相当于从尾到头打印了。 但是修改输入数据真的可行么？ 剑指Offer中为我们在面试中提出了如下小提示 在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改 通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容 如果要求反转的话，直接头插法就可以了 实现思路12345678910111213141516171819202122232425262728293031package mainimport (4"fmt")type NodeList struct { Val int Next *NodeList}// 不修改输入数据，只从尾到头打印链表func printListFromTailToHead(head *NodeList) { if head != nil { printListFromTailToHead(head.Next) fmt.Printf("%d ->", head.Val) }}func main() { n3 := &NodeList(3, nil) n2 := &NodeList(2, n3) n1 := &NodeList(1, n2) fmt.Printf("\n NodeList 1 -> 2 -> 3 \n") //test fmt.Printf("\n Output: ") printListFromTailToHead(n1) fmt.Printf("\n \n")}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数相加-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[统计字符个数-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[判断回文字符串-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[找出完数-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%89%BE%E5%87%BA%E5%AE%8C%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】替换空格]]></title>
    <url>%2F2019%2F06%2F12%2F%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 We Are Happy We%20Are%20Happy 如果不考虑在原来的字符串上替换的话, 那么我们直接再开一个数组，从前往后依次赋值 遇见空格，就填上%20, 否则就填当前字符。 但是这个肯定不是面试官期待的 那么怎么在原字符串上进行高效的替换呢？ 实现思路123456789101112131415161718192021222324package mainfunc replaceSpace(str []byte, length int) string { count := 0 for i := 0; i < length -1; i++ { count++ } newlength := length + count*2 for l, nl := length-1;newlength-1; l > 0 && nl > 0 ;{ if str[l] == ' ' { str[nl] = '0' nl-- str[nl] = '2' nl-- str[nl] = '%' nl-- l-- } else { str[nl] = str[l] nl-- l-- } }} 测试123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "testing" "github.com/stretchr/testify/assert")type para struct { str []byte length int}type ans struct { res []byte}type question struct { p para a ans}func Test_OK(t *testing.T) { ast := assert.New(t) qs := []question{ question{ p: para{ str: []byte{'a',' ','b',' ','c','x','x','x','x'}, length: 5, }, a: ans{ res: []byte{'a','%','2','0','b','%','2','0','c'}, }, }, } for _, q := range qs { a, p := q.a, q.p replaceSpace(p.str, p.length) ast.Equal(string(a.res), string(p.str), "输入:%v", p) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序-golang实现]]></title>
    <url>%2F2019%2F06%2F11%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[描述选择排序的核心就是遍历数组，每次遍历都将当前位置 i 当作最小的数字，然后向后逐一比较，选出最小的数字的位置，与 i 位置所在的数字进行调换。 代码1234567891011121314151617package mainfunc SelectionSort(arr []int) []int { len := len(arr) var minIndex int for i := 0; i < len -1; i++ { // 注意是 < len - 1 minIndex = i for j := i + 1; j < len ; j ++ { // 注意是 < len if arr[j] < arr[minIndex] { minIndex = j // 不断往后遍历，找到最小的进行选择替换 } } arr[i], arr[minIndex] = arr[minIndex], arr[i] } return arr} 测试1234567891011package selectionimport ( "testing")func Test_selectSort(t *testing.T) { arr := []int{1, 5, 23, 6, 3, 1, 7} arr = SelectSort(arr) t.Log(arr)}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n的阶乘之和-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2Fn%E7%9A%84%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目对于一个数n，求n的阶乘之和，即： 1！ + 2！ + 3！+…n! 代码12345678910111213141516171819202122232425package mainimport (4"fmt")func sum(n int) uint64 {4var s uint64 = 1 var sum uint64 = 0 // 3! = 2！* 1 for i := 1; i]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求水仙花数-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%B1%82%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目打印出100-999中所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153 是一个“水仙花数”，因为 153 = 1的三次方 ＋ 5的三次方 ＋ 3的三次方。 代码：方式一12345678910111213141516171819202122232425262728package mainimport(4"fmt")func isNumber(n int) bool { var i, j, k int i = n % 10 j = (n / 10) % 10 k = (n / 100) % 10 sum := i*i*i + k*k*k + j*j*j return sum == n}func main(){ var m int var n int // scanf 默认是空格分隔的 fmt.Scanf("%d%d", &n, &m) for i := n; i < m; i++ { if isNumber(i) { fmt.Println(i) } }} 代码：方式二1234567891011121314151617181920212223242526272829package mainimport(4"fmt" "strconv")func main() { var str string fmt.Scanf("%s", &str) var result = 0 for i := 0; i < len(str); i++ { num := int(str[i] - '0') // ASCII result += (num * num * num) } number, err := strconv.Atoi(str) if err != nil { fmt.Printf("can not convert %s to int\n", str) return } if result == number { fmt.Printf("%d is shuixianhuashu\n", number) } else { fmt.Printf("%d is not shuixianhuashu", number) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断素数-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目判断 101-200 之间有多少个素数，并输出所有素数 代码123456789101112131415161718192021222324252627package mainimport (4"fmt" "math")func isPrime(n int) bool { for i := 2; i]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】二维数组中的查找]]></title>
    <url>%2F2019%2F05%2F29%2F%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 输入描述 array： 待查找的二维数组 target：查找的数字 输出描述 查找到返回true，查找不到返回false 实现思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package problem003// 用了分治的思想，根据题意可得// 从数组中选取数字，和目标数字的关系有三种情况：=，。// 如果是等于则查找成功；// 如果是数组中元素小于要查找的数字，说明要查找的数字应该在当前位置的右边或下边。// 如果是数组中元素大于要查找的数字，说明要查找的数字应该在当前位置的左边或上边。// 即 对于数组中的任何一个元素, 比它小的元素都在它的左方或者上方, 比它大的元素都在它的右边或者下方// 但是这两个区域还有可能有重叠，比如右边或下边会在右下角有重叠。// 为了不重复的处理重叠的数据, 我们可以找几个特殊的起点, 比如// 起点 性质 可否作为起点// 左上角 没有上方元素(小)和左方元素(小)// 只有下方元素(大)和右方元素(大) 否// 右上角 没有上方元素(小), 和右方元素(大)// 只有下方元素(大)和左方元素(小) 是// 左下角 没有下方元素(大), 和左方元素(小)// 只有上方元素(小)和右方元素(大) 是// 右下角 没有下方元素(大), 和右方元素(大)// 只有上方元素(小)和左方元素(小) 否// 因此重叠问题的解决方法：// 如果查找从右上角开始，如果要查找的数字不在右上角，则每次可以剔除一列或一行。// 也可以从左下角开始// 但是不能从左上角或者右下角开始。func Find(board [][]int, target int) bool { rlen := len(board) // 行 clen := len(board[0]) // 列 // 从右上角开始查找 for r,c := 0, clen-1; r < rlen-1 && c > 0; { if board[r][c] == target { return true } if board[r][c] > target { // 往左边查找 c-- continue } else { // 往下边查找 r++ } } return false // 从左下角开始查找 // for r,c := rlen-1, 0; r > 0 && c < clen-1; { // if board[r][c] == target { // return true // } // if board[r][c] > target { // // 往上边查找 // r-- // } else { // // 往右边查找 // c++ // continue // } // } // return false} 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package problem003import ( "testing" "github.com/stretchr/testify/assert")type para struct { board [][]int target int}type ans struct { find bool}type question struct { p para a ans}func Test_OK(t *testing.T) { ast := assert.New(t) qs := []question{ question{ p: para{ board: [][]int{ []int{ 1, 2, 8, 9, }, []int{ 2, 4, 9, 12, }, []int{ 4, 7, 10, 13, }, []int{ 6, 8, 11, 15, }, }, target: 7, }, a: ans{ find: true, }, }, question{ p: para{ board: [][]int{ []int{ 1, 2, 8, 9, }, []int{ 2, 4, 9, 12, }, []int{ 4, 6, 10, 13, }, []int{ 6, 8, 11, 15, }, }, target: 7, }, a: ans{ find: false, }, }, } for _, q := range qs { a, p := q.a, q.p ast.Equal(a.find, Find(p.board, p.target), "输入:%v", p) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(一)]]></title>
    <url>%2F2019%2F05%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[计算机网络定义 定义：计算机网络是一个将分散的、具有独立功能的计算机系统（端系统），通过通信设备（交换机、路由器）与线路（通信设备与端系统连接的介质）连接起来，由功能完善的软件实现资源共享和信息传递的系统。 计算机网络就是互连、自治的计算机集合。 计算机网络功能 数据通信 连通性 资源共享 硬件 软件 数据 分布式处理 多台计算机各自承担同一工作任务的不同部分 Hadoop平台 提高可靠性 替代机 负载均衡 … 计算机组成部分 组成部分 硬件 软件 协议 工作方式 边缘部分（用户直接使用） C/S方式 P2P方式 核心部分（为边缘部分服务） 路由器 网络 功能组成 通信子网 实现数据通信 资源子网 实现资源共享/数据处理 计算机网络分类 按分布范围 广域网WAN 交换技术 城域网MAN 局域网LAN 广播技术 个人区域网PAN 按使用者分 公用网 专用网 按交换技术分 电路交换 报文交换 分组交换 按拓扑结构来分 总线型 星型 环型 网状型 常用于广域网 按传输技术分 广播式网络 共享公共通信信道 点对点网络 使用分组存储转发和路由选择机制 标准化工作及组织国际标准化组织ISO 制定了OSI参考模型和HDLC协议 性能指标速率速率即数据率或称数据传输率或比特率 带宽在计算机网络中，带宽指网络的通信线路传送数据的能力，通常指单位时间内传输的”最高数据率“，单位是”比特每秒”, b/s，kb/s，Mb/s，Gb/s。 简而言之，可以理解为网络设备所支持的最高速度。 吞吐量表示在单位时间内通过某个网络 或信道、接口的数据量。单位 b/s，kb/s，Mb/s等。受网络的带宽和额定速率限制。 时延指数据从网络或链路的一端到另一端所需时间，也叫延时或迟延，单位为s。 发送时延(传输时延) 传播时延 排队时延 处理时延 时延带宽积时延带宽积(bit) = 传播时延(s) x 带宽(b/s) 时延带宽积本质上是以比特为单位的链路长度，也就是某链路此时此刻的数据容量。 往返时延RTT从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总经历的时延。 注：RTT越大，在收到确认之前，可以发送的数据越多。 RTT包括 往返传播时延 = 传播时延 * 2 末端处理时间 利用率 信道利用率 网络利用率]]></content>
      <categories>
        <category>技术</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表入门]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[哈希表是一种以键值对来组织数据的数据结构，它需要哈希函数，用来支持快速地插入和搜索数据。 哈希表的原理 哈希表的关键是通过哈希函数，将键( key )映射到存储桶(Bucket)： \1. 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中； \2. 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。 设计哈希表的关键 哈希函数哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。 哈希函数（散列函数）取决于键值的范围和桶的数量。 可以看一下哈希函数的示例： 设计哈希函数的思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射，然而很多时候是没办法达到完美的，只能在桶的数量和桶的容量之间做出权衡。 冲突解决在大多数情况下，冲突几乎是不可避免的。 假设我们用 y = x ％ 5 作为哈希函数，1987 和 2 都分配给了桶 2，这是一个冲突。 冲突解决算法应该解决以下几个问题： \1. 如何组织在同一个桶中的值？ \2. 如果为同一个桶分配了太多的值，该怎么办？ \3. 如何在特定的桶中搜索目标值？ 这些问题都跟桶的容量和可能映射到同一个桶的键的数量有关。 一般来说，假设一个桶的最大存储键的数量为 n ，如果这个 n 是常数或者比较小，可以直接用一个数组来代表桶，如果这个 n 是可变或很大，我们就需要用到高度平衡的二叉树来做了。 通过代码理解哈希表no code no talk. 了解了哈希的基本概念后，怎么也得去学一下用代码实现才能真正地理解吧。 下面就用 golang 来实现简单的 哈希集合 hashset 与 哈希映射 hashmap。要知道，哈希表中插入和搜索是最基本的操作了，实现中也是主要包含这些部分。 建议看到要求后，自己想一想该怎么实现比较好，用自己擅长的语言即可。 设计哈希集合要求： 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789101112131415161718> MyHashSet hashSet = new MyHashSet();> > hashSet.add(1); > > hashSet.add(2); > > hashSet.contains(1); // 返回 true> > hashSet.contains(3); // 返回 false (未找到)> > hashSet.add(2); > > hashSet.contains(2); // 返回 true> > hashSet.remove(2); > > hashSet.contains(2); // 返回 false (已经被删除)> 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type MyHashSet struct { table []bool }/** Initialize your data structure here. */func Constructor() MyHashSet { return MyHashSet{table:make([]bool,1000001)} }func (this *MyHashSet) Add(key int) { this.table[key] = true }func (this *MyHashSet) Remove(key int) { this.table[key] = false }/** Returns true if this set contains the specified element */func (this *MyHashSet) Contains(key int) bool { return this.table[key]}/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */ 设计哈希映射要求: 不使用任何内建的哈希表库设计一个哈希映射 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 示例： 123456789101112131415161718> MyHashMap hashMap = new MyHashMap();> > hashMap.put(1, 1); > > hashMap.put(2, 2); > > hashMap.get(1); // 返回 1> > hashMap.get(3); // 返回 -1 (未找到)> > hashMap.put(2, 1); // 更新已有的值> > hashMap.get(2); // 返回 1 > > hashMap.remove(2); // 删除键为2的数据> > hashMap.get(2); // 返回 -1 (未找到) > 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127type KV struct { K int V int}type MyHashMap struct { data [1000][]KV}func hash(key int) int { return key%1000}/** Initialize your data structure here. */func Constructor() MyHashMap { return MyHashMap{[1000][]KV{}}}/** value will always be non-negative. */func (this *MyHashMap) Put(key int, value int) { h := hash(key) bkt := this.data[h] insert := -1 for i := 0; i < len(bkt); i++ { if bkt[i].K == key { bkt[i].V = value return } if bkt[i].K == -1 { insert = i } } if insert != -1 { bkt[insert].K = key bkt[insert].V = value } else { this.data[h] = append(bkt, KV{key, value}) }}/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */func (this *MyHashMap) Get(key int) int { h := hash(key) bkt := this.data[h] for _, k := range bkt { if k.K == key { return k.V } } return -1}/** Removes the mapping of the specified value key if this map contains a mapping for the key */func (this *MyHashMap) Remove(key int) { h := hash(key) bkt := this.data[h] for i := 0; i < len(bkt); i++ { if bkt[i].K == key { bkt[i].K = -1 return } }}/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 以上代码借鉴于 leetcode 复杂度分析空间复杂度关于哈希表的空间复杂度，其实也比较明显了，也就是当有 M 个键的时候，那哈希表的空间复杂度也是 O(M) 。 时间复杂度而时间复杂度呢，按照上面的说法，即跟桶的最大存储键值得大小有关，如果存储最大值是个常数，我们可以用数组来当桶，那插入和搜索的时间复杂度都是 O(1)。 如果在最坏的情况下，桶大小的最大值将为 N，也就是可变的，那我们就会用到高度平衡的二叉树作为桶。插入时时间复杂度为 O(1)，搜索时为 O(N)。 内置的哈希表原理 内置哈希表的典型设计是： \1. 键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有hashcode 。此 hashcode 可以通过映射函数来获得存储区索引。 \2. 每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。 \3. 如果在同一个桶中有太多的值（会设置临界值进行判断），这些值将被保留在一个高度平衡的二叉树搜索树中。 这样设计带来的好处便是，插入和搜索的平均时间复杂度仍为 O(1)。 最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。很显然，这需要对这个临界值的设置有巧妙的处理。 今天就讲这么多啦，希望通过本篇的讲解，能让大家对哈希表的结构及原理有更深刻的认识，也十分欢迎大家能在评论区发表自己的看法哦 我是鱼卷少年，我们下次见。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【leetcode】136.只出现一次的数字]]></title>
    <url>%2F2019%2F04%2F22%2Fleetcode136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[leetcode题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 思路 1：我在做这个题的时候，首先是想到了暴力的解法，也就是两层 for 循环，逐一比对，自身与自身不比较，就可以获得答案，我是用 go 写的，代码如下： 12345678910111213141516171819202122232425func singleNumber(nums []int) int { length := len(nums) if length == 1 { return nums[0] } target := nums[0] for i:= 0; i < length; i++ { flag := true for j := 0; j < length; j++ { if i == j { continue } else if nums[i] == nums[j] { flag = false break } } if flag { target = nums[i] return target } } return target} 显然，这并未达到线性时间复杂度，所以肯定有优化的空间，那究竟用什么方法才可以减少时间复杂度呢？ 其实根据这个，言下之意，通过某种方法，可以只用一层循环就可以达到目的。随即想了好久后，我得出： 思路 2：可以通过位运算中的异或运算来做，因为题目说了，只有一个是不同的，其他都是两个相同的数字，用异或，可以让两个相同的数变为 0。 1234567func singleNumber(nums []int) int { result := 0 for _, val := range nums { result ^= val } return result} 好的，提交完成，代码通过。 那么问题来了： 为什么会用到异或呢？异或的本质是什么？ 如果拓展到有三个数相同，而不是两个数相同，又该怎么做呢？ 欢迎在评论区评论，说说你的想法。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
