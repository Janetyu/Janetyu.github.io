<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP与UDP的区别]]></title>
    <url>%2F2019%2F12%2F01%2FTCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP 与 UDP 的特点 TCP 是基于连接的可靠的传输协议，UDP 是基于无连接的不可靠的传输协议 TCP 提供超时重传、丢弃重复数据、检验数据、流量控制等功能，UDP 没有提供这些功能。 提供这些功能会加大网络带宽的开销，“虚拟信道”和网络中的大量“ ACK、FIN ”包是最主要的开销。 TCP 因为开销的原因，不适合作为实时通信，因此会选择开销很小的 UDP 协议。 UDP 因为是无连接不可靠的，没有重传机制，因此会发生丢包、收到重复包、乱序等问题。 总结TCP 与 UDP 的区别 基于连接与无连接 TCP 提供可靠的传输，有确认机制，UDP 不提供可靠性，不能保证数据能达到目的地 对于系统网络资源的开销（TCP 多，UDP 少） TCP 结构相对复杂，UDP 结构简单 TCP 面向字节流模式，会保证服务端按顺序接收到全部的字节流，UDP 面向数据报模式，不保证顺序性 运用强调数据传输的完整性、可靠性、可控制性，选择 TCP 协议， 强调数据传输的性能，选择 UDP 协议，如：音频、多媒体应用、DNS 交换。 TCP 功能丰富，但相对的性能会降低。]]></content>
      <categories>
        <category>技术</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-重建二叉树]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 输入 前序遍历序列{1,2,4,7,3,5,6,8} 中序遍历序列{4,7,2,1,5,3,8,6} 则重建二叉树并返回。 分析这道题还是比较简单的，我们知道 前序遍历的顺序为：根左右 中序遍历的顺序为：左根右 递归思想: 我们先根据前序遍历序列的第一个确定根，然后在中序遍历的序列中找到根的位置，根左边的就是其左子树，右边就是其右子树 构建根和左右子树 递归的进行1和2 实现思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( "fmt")type TreeNode struct { Val int Left *TreeNode Right *TreeNode}func printPreOrder(root *TreeNode) { if root != nil { fmt.Printf("%d ", root.Val) printInOrder(root.Left) printInOrder(root.Right) }}func printInOrder(root *TreeNode) { if root != nil { printInOrder(root.Left) fmt.Printf("%d ", root.Val) printInOrder(root.Right) }}func reConstructBinaryTree(pre []int,in []int) *TreeNode { if len(pre) != len(in) || len(pre) == 0 { return nil } // find root in preOrder and rootIndex in InOrder rootVal := pre[0] rootIndex := 0 for i := 0; i < len(in) ; i++ { if in[i] == rootVal { rootIndex = i } } inL,inR := in[:rootIndex],in[rootIndex+1:] preL, preR := pre[1:rootIndex+1],pre[rootIndex+1:] Left := reConstructBinaryTree(preL,inL) Right := reConstructBinaryTree(preR,inR) return &TreeNode{Val: rootVal, Left: Left, Right: Right}}func main() { pre := []int{1,2,4,7,3,5,6,8} in := []int{4,7,2,1,5,3,6,8} fmt.Println("preOder: ", pre) fmt.Println("inOrder: ", in) // Reconstruct fmt.Println("\nReconstruct Binary Tree... \n ",) root := reConstructBinaryTree(pre, in) // test fmt.Printf("preOder from Tree reconstructed: ") printPreOrder(root) fmt.Printf("\n") fmt.Printf("inOder from Tree reconstructed: ") printInOrder(root) fmt.Printf("\n")}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-从尾到头打印链表]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，从尾到头打印链表每个节点的值。 输入描述: 输入为链表的表头 输出描述: 输出为需要打印的“新链表”的表头 反转链表首先我们想到的就是反转链表了,如果把链表反转了，然后再返回头，这样再次遍历的时候就相当于从尾到头打印了。 但是修改输入数据真的可行么？ 剑指Offer中为我们在面试中提出了如下小提示 在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改 通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容 如果要求反转的话，直接头插法就可以了 实现思路12345678910111213141516171819202122232425262728293031package mainimport (4"fmt")type NodeList struct { Val int Next *NodeList}// 不修改输入数据，只从尾到头打印链表func printListFromTailToHead(head *NodeList) { if head != nil { printListFromTailToHead(head.Next) fmt.Printf("%d ->", head.Val) }}func main() { n3 := &NodeList(3, nil) n2 := &NodeList(2, n3) n1 := &NodeList(1, n2) fmt.Printf("\n NodeList 1 -> 2 -> 3 \n") //test fmt.Printf("\n Output: ") printListFromTailToHead(n1) fmt.Printf("\n \n")}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数相加-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目计算两个大数相加的和，这两个大数会超过int64的表示范围 解题思路既然数值已超过 int64，那就不能用数值的方式进行计算（当然也不可能这么简单），另辟蹊径，我们可以运用字符串的方式进行处理，这里注意边界判断处理以及进位的处理，特别是最后一个进位，如果忘记拼接到结果处，则会变成首位为 0 的尴尬情况。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( "fmt" "bufio" "os" "strings")func bigNumSum(a, b string) (result string) { if len(a) == 0 && len(b) == 0 { result = "0" return } var index1 = len(a) - 1 var index2 = len(b) - 1 var add int // 进位 for index1 >= 0 && index2 >= 0 { c1 := a[index1] - '0' // ASCII转数字的方法 c2 := b[index2] - '0' sum := int(c1) + int(c2) + add if sum >= 10 { // 处理进位 add = 1 } else { add = 0 } c3 := (sum % 10) + '0' // 转回byte result = fmt.Sprintf("%c%s", c3, result) index1-- index2-- } for index1 >= 0 { c1 := a[index1] - '0' sum := int(c1) + add if sum >= 10 { // 处理进位 add = 1 } else { add = 0 } c3 := (sum % 10) + '0' // 转回byte result = fmt.Sprintf("%c%s", c3, result) // 注意%c在前 index1-- } for index2 >= 0 { c2 := b[index2] - '0' sum := int(c2) + add if sum >= 10 { // 处理进位 add = 1 } else { add = 0 } c3 := (sum % 10) + '0' // 转回byte result = fmt.Sprintf("%c%s", c3, result) // 注意%c在前 index2-- } if add == 1 { result = fmt.Sprintf("%d%s", add, result) } return}func main() { reader := bufio.NewReader(os.Stdin) result, _, err := reader.ReadLine() if err != nil { fmt.Println("read from console err : ",err) return } str := strings.Split(string(result), "+") if len(str) != 2 { fmt.Println("must input a+b") return } strNumber1 := strings.TrimSpace(str[0]) strNumber2 := strings.TrimSpace(str[1]) fmt.Println("the two big num Sum is ", bigNumSum(strNumber1, strNumber2))}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计字符个数-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。 代码实现12345678910111213141516171819202122232425262728293031323334353637package mainimport ( "fmt" "bufio" "os")func count(str string) (wordCount, spaceCount, numberCount, otherCount int) { t := []rune(str) for _, v := range t { switch { case v >= 'a' && v = 'A' && v = '0' && v]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断回文字符串-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目输入一个字符串，判断其是否为回文。回文字符串是指从左到右读和从右到左读完全相同的字符串。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport "fmt"// 不适用于中文，因为一个中文占3个字节，转成 rune 字符类型进行判断func process(str string) bool { for i := 0; i < len(str); i++ { if i == len(str)/2 { // 终止条件 break } last := len(str) - i -1 if str[i] != str[last] { return false } } return true}// 适用于中文，英文，数字func process2(str string) bool { t := []rune(str) length := len(t) for i, _ := range t { if i == length/2 { // 终止条件 break } last := length - i -1 if t[i] != t[last] { return false } } return true}func main() { var str string fmt.Scanf("%s",&str) if process(str) { fmt.Printf("%s 是回文串", str) } else { fmt.Printf("%s 不是回文串", str) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出完数-golang实现]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%89%BE%E5%87%BA%E5%AE%8C%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如6=1＋2＋3.编程找出1000以内的所有完数。 代码实现1234567891011121314151617181920212223242526package mainimport ( "fmt")func isPerfectNum(num int) bool { var sum int for i := 1; i < num; i++ { if num % i == 0 { sum += i } } return sum == num}func main() { var start,end int fmt.Scanf("%d %d",&start,&end) for i := start; i]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-替换空格]]></title>
    <url>%2F2019%2F06%2F12%2F%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 We Are Happy We%20Are%20Happy 如果不考虑在原来的字符串上替换的话, 那么我们直接再开一个数组，从前往后依次赋值 遇见空格，就填上%20, 否则就填当前字符。 但是这个肯定不是面试官期待的 那么怎么在原字符串上进行高效的替换呢？ 实现思路123456789101112131415161718192021222324package mainfunc replaceSpace(str []byte, length int) string { count := 0 for i := 0; i < length -1; i++ { count++ } newlength := length + count*2 for l, nl := length-1;newlength-1; l > 0 && nl > 0 ;{ if str[l] == ' ' { str[nl] = '0' nl-- str[nl] = '2' nl-- str[nl] = '%' nl-- l-- } else { str[nl] = str[l] nl-- l-- } }} 测试123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "testing" "github.com/stretchr/testify/assert")type para struct { str []byte length int}type ans struct { res []byte}type question struct { p para a ans}func Test_OK(t *testing.T) { ast := assert.New(t) qs := []question{ question{ p: para{ str: []byte{'a',' ','b',' ','c','x','x','x','x'}, length: 5, }, a: ans{ res: []byte{'a','%','2','0','b','%','2','0','c'}, }, }, } for _, q := range qs { a, p := q.a, q.p replaceSpace(p.str, p.length) ast.Equal(string(a.res), string(p.str), "输入:%v", p) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序-golang实现]]></title>
    <url>%2F2019%2F06%2F11%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[描述选择排序的核心就是遍历数组，每次遍历都将当前位置 i 当作最小的数字，然后向后逐一比较，选出最小的数字的位置，与 i 位置所在的数字进行调换。 代码1234567891011121314151617package mainfunc SelectionSort(arr []int) []int { len := len(arr) var minIndex int for i := 0; i < len -1; i++ { // 注意是 < len - 1 minIndex = i for j := i + 1; j < len ; j ++ { // 注意是 < len if arr[j] < arr[minIndex] { minIndex = j // 不断往后遍历，找到最小的进行选择替换 } } arr[i], arr[minIndex] = arr[minIndex], arr[i] } return arr} 测试1234567891011package selectionimport ( "testing")func Test_selectSort(t *testing.T) { arr := []int{1, 5, 23, 6, 3, 1, 7} arr = SelectSort(arr) t.Log(arr)}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n的阶乘之和-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2Fn%E7%9A%84%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目对于一个数n，求n的阶乘之和，即： 1！ + 2！ + 3！+…n! 代码12345678910111213141516171819202122232425package mainimport ( "fmt")func sum(n int) uint64 { var s uint64 = 1 var sum uint64 = 0 // 3! = 2！* 1 for i := 1; i]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求水仙花数-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%B1%82%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目打印出100-999中所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153 是一个“水仙花数”，因为 153 = 1的三次方 ＋ 5的三次方 ＋ 3的三次方。 代码：方式一12345678910111213141516171819202122232425262728package mainimport( "fmt")func isNumber(n int) bool { var i, j, k int i = n % 10 j = (n / 10) % 10 k = (n / 100) % 10 sum := i*i*i + k*k*k + j*j*j return sum == n}func main(){ var m int var n int // scanf 默认是空格分隔的 fmt.Scanf("%d%d", &n, &m) for i := n; i < m; i++ { if isNumber(i) { fmt.Println(i) } }} 代码：方式二1234567891011121314151617181920212223242526272829package mainimport( "fmt" "strconv")func main() { var str string fmt.Scanf("%s", &str) var result = 0 for i := 0; i < len(str); i++ { num := int(str[i] - '0') // ASCII result += (num * num * num) } number, err := strconv.Atoi(str) if err != nil { fmt.Printf("can not convert %s to int\n", str) return } if result == number { fmt.Printf("%d is shuixianhuashu\n", number) } else { fmt.Printf("%d is not shuixianhuashu", number) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断素数-golang实现]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0-golang%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目判断 101-200 之间有多少个素数，并输出所有素数 代码123456789101112131415161718192021222324252627package mainimport (4"fmt" "math")func isPrime(n int) bool { for i := 2; i]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二维数组中的查找]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 输入描述 array： 待查找的二维数组 target：查找的数字 输出描述 查找到返回true，查找不到返回false 实现思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package problem003// 用了分治的思想，根据题意可得// 从数组中选取数字，和目标数字的关系有三种情况：=，。// 如果是等于则查找成功；// 如果是数组中元素小于要查找的数字，说明要查找的数字应该在当前位置的右边或下边。// 如果是数组中元素大于要查找的数字，说明要查找的数字应该在当前位置的左边或上边。// 即 对于数组中的任何一个元素, 比它小的元素都在它的左方或者上方, 比它大的元素都在它的右边或者下方// 但是这两个区域还有可能有重叠，比如右边或下边会在右下角有重叠。// 为了不重复的处理重叠的数据, 我们可以找几个特殊的起点, 比如// 起点 性质 可否作为起点// 左上角 没有上方元素(小)和左方元素(小)// 只有下方元素(大)和右方元素(大) 否// 右上角 没有上方元素(小), 和右方元素(大)// 只有下方元素(大)和左方元素(小) 是// 左下角 没有下方元素(大), 和左方元素(小)// 只有上方元素(小)和右方元素(大) 是// 右下角 没有下方元素(大), 和右方元素(大)// 只有上方元素(小)和左方元素(小) 否// 因此重叠问题的解决方法：// 如果查找从右上角开始，如果要查找的数字不在右上角，则每次可以剔除一列或一行。// 也可以从左下角开始// 但是不能从左上角或者右下角开始。func Find(board [][]int, target int) bool { rlen := len(board) // 行 clen := len(board[0]) // 列 // 从右上角开始查找 for r,c := 0, clen-1; r < rlen-1 && c > 0; { if board[r][c] == target { return true } if board[r][c] > target { // 往左边查找 c-- continue } else { // 往下边查找 r++ } } return false // 从左下角开始查找 // for r,c := rlen-1, 0; r > 0 && c < clen-1; { // if board[r][c] == target { // return true // } // if board[r][c] > target { // // 往上边查找 // r-- // } else { // // 往右边查找 // c++ // continue // } // } // return false} 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package problem003import ( "testing" "github.com/stretchr/testify/assert")type para struct { board [][]int target int}type ans struct { find bool}type question struct { p para a ans}func Test_OK(t *testing.T) { ast := assert.New(t) qs := []question{ question{ p: para{ board: [][]int{ []int{ 1, 2, 8, 9, }, []int{ 2, 4, 9, 12, }, []int{ 4, 7, 10, 13, }, []int{ 6, 8, 11, 15, }, }, target: 7, }, a: ans{ find: true, }, }, question{ p: para{ board: [][]int{ []int{ 1, 2, 8, 9, }, []int{ 2, 4, 9, 12, }, []int{ 4, 6, 10, 13, }, []int{ 6, 8, 11, 15, }, }, target: 7, }, a: ans{ find: false, }, }, } for _, q := range qs { a, p := q.a, q.p ast.Equal(a.find, Find(p.board, p.target), "输入:%v", p) }}]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表入门]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[哈希表是一种以键值对来组织数据的数据结构，它需要哈希函数，用来支持快速地插入和搜索数据。 哈希表的原理 哈希表的关键是通过哈希函数，将键( key )映射到存储桶(Bucket)： \1. 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中； \2. 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。 设计哈希表的关键 哈希函数哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。 哈希函数（散列函数）取决于键值的范围和桶的数量。 可以看一下哈希函数的示例： 设计哈希函数的思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射，然而很多时候是没办法达到完美的，只能在桶的数量和桶的容量之间做出权衡。 冲突解决在大多数情况下，冲突几乎是不可避免的。 假设我们用 y = x ％ 5 作为哈希函数，1987 和 2 都分配给了桶 2，这是一个冲突。 冲突解决算法应该解决以下几个问题： \1. 如何组织在同一个桶中的值？ \2. 如果为同一个桶分配了太多的值，该怎么办？ \3. 如何在特定的桶中搜索目标值？ 这些问题都跟桶的容量和可能映射到同一个桶的键的数量有关。 一般来说，假设一个桶的最大存储键的数量为 n ，如果这个 n 是常数或者比较小，可以直接用一个数组来代表桶，如果这个 n 是可变或很大，我们就需要用到高度平衡的二叉树来做了。 通过代码理解哈希表no code no talk. 了解了哈希的基本概念后，怎么也得去学一下用代码实现才能真正地理解吧。 下面就用 golang 来实现简单的 哈希集合 hashset 与 哈希映射 hashmap。要知道，哈希表中插入和搜索是最基本的操作了，实现中也是主要包含这些部分。 建议看到要求后，自己想一想该怎么实现比较好，用自己擅长的语言即可。 设计哈希集合要求： 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: 123456789101112131415161718> MyHashSet hashSet = new MyHashSet();> > hashSet.add(1); > > hashSet.add(2); > > hashSet.contains(1); // 返回 true> > hashSet.contains(3); // 返回 false (未找到)> > hashSet.add(2); > > hashSet.contains(2); // 返回 true> > hashSet.remove(2); > > hashSet.contains(2); // 返回 false (已经被删除)> 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type MyHashSet struct { table []bool }/** Initialize your data structure here. */func Constructor() MyHashSet { return MyHashSet{table:make([]bool,1000001)} }func (this *MyHashSet) Add(key int) { this.table[key] = true }func (this *MyHashSet) Remove(key int) { this.table[key] = false }/** Returns true if this set contains the specified element */func (this *MyHashSet) Contains(key int) bool { return this.table[key]}/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */ 设计哈希映射要求: 不使用任何内建的哈希表库设计一个哈希映射 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 示例： 123456789101112131415161718> MyHashMap hashMap = new MyHashMap();> > hashMap.put(1, 1); > > hashMap.put(2, 2); > > hashMap.get(1); // 返回 1> > hashMap.get(3); // 返回 -1 (未找到)> > hashMap.put(2, 1); // 更新已有的值> > hashMap.get(2); // 返回 1 > > hashMap.remove(2); // 删除键为2的数据> > hashMap.get(2); // 返回 -1 (未找到) > 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127type KV struct { K int V int}type MyHashMap struct { data [1000][]KV}func hash(key int) int { return key%1000}/** Initialize your data structure here. */func Constructor() MyHashMap { return MyHashMap{[1000][]KV{}}}/** value will always be non-negative. */func (this *MyHashMap) Put(key int, value int) { h := hash(key) bkt := this.data[h] insert := -1 for i := 0; i < len(bkt); i++ { if bkt[i].K == key { bkt[i].V = value return } if bkt[i].K == -1 { insert = i } } if insert != -1 { bkt[insert].K = key bkt[insert].V = value } else { this.data[h] = append(bkt, KV{key, value}) }}/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */func (this *MyHashMap) Get(key int) int { h := hash(key) bkt := this.data[h] for _, k := range bkt { if k.K == key { return k.V } } return -1}/** Removes the mapping of the specified value key if this map contains a mapping for the key */func (this *MyHashMap) Remove(key int) { h := hash(key) bkt := this.data[h] for i := 0; i < len(bkt); i++ { if bkt[i].K == key { bkt[i].K = -1 return } }}/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 以上代码借鉴于 leetcode 复杂度分析空间复杂度关于哈希表的空间复杂度，其实也比较明显了，也就是当有 M 个键的时候，那哈希表的空间复杂度也是 O(M) 。 时间复杂度而时间复杂度呢，按照上面的说法，即跟桶的最大存储键值得大小有关，如果存储最大值是个常数，我们可以用数组来当桶，那插入和搜索的时间复杂度都是 O(1)。 如果在最坏的情况下，桶大小的最大值将为 N，也就是可变的，那我们就会用到高度平衡的二叉树作为桶。插入时时间复杂度为 O(1)，搜索时为 O(N)。 内置的哈希表原理 内置哈希表的典型设计是： \1. 键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有hashcode 。此 hashcode 可以通过映射函数来获得存储区索引。 \2. 每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。 \3. 如果在同一个桶中有太多的值（会设置临界值进行判断），这些值将被保留在一个高度平衡的二叉树搜索树中。 这样设计带来的好处便是，插入和搜索的平均时间复杂度仍为 O(1)。 最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。很显然，这需要对这个临界值的设置有巧妙的处理。 今天就讲这么多啦，希望通过本篇的讲解，能让大家对哈希表的结构及原理有更深刻的认识，也十分欢迎大家能在评论区发表自己的看法哦 我是鱼卷少年，我们下次见。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【leetcode】136.只出现一次的数字]]></title>
    <url>%2F2019%2F04%2F22%2Fleetcode136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[leetcode题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 思路 1：我在做这个题的时候，首先是想到了暴力的解法，也就是两层 for 循环，逐一比对，自身与自身不比较，就可以获得答案，我是用 go 写的，代码如下： 12345678910111213141516171819202122232425func singleNumber(nums []int) int { length := len(nums) if length == 1 { return nums[0] } target := nums[0] for i:= 0; i < length; i++ { flag := true for j := 0; j < length; j++ { if i == j { continue } else if nums[i] == nums[j] { flag = false break } } if flag { target = nums[i] return target } } return target} 显然，这并未达到线性时间复杂度，所以肯定有优化的空间，那究竟用什么方法才可以减少时间复杂度呢？ 其实根据这个，言下之意，通过某种方法，可以只用一层循环就可以达到目的。随即想了好久后，我得出： 思路 2：可以通过位运算中的异或运算来做，因为题目说了，只有一个是不同的，其他都是两个相同的数字，用异或，可以让两个相同的数变为 0。 1234567func singleNumber(nums []int) int { result := 0 for _, val := range nums { result ^= val } return result} 好的，提交完成，代码通过。 那么问题来了： 为什么会用到异或呢？异或的本质是什么？ 如果拓展到有三个数相同，而不是两个数相同，又该怎么做呢？ 欢迎在评论区评论，说说你的想法。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
